# 완전 탐색(Exhaustive Search)

가능한 모든 경우의 수를 전부 체크하여 정답을 찾는 방법. 존재하는 모든 답을 하나씩 검사하기 때문에, 소요되는 시간은 답의 갯수에 정확히 비례함. 따라서 코테에서 문제의 최대 입력 크기를 가정했을 때 답의 갯수를 계산해보고, 이들 전부를 제한 시간 안에 생성할 수 있을지를 가늠해봐야 함. 만약 최대 입력 크기에 대해 시간 내에 계산이 불가능하다면, 다른 설계 패러다임을 활용해야 함.

<br/>

---
## :one:&ensp; 완전 탐색 기법

완전 탐색 자체가 알고리즘이 아니기 떄문에, 완전 탐색 방식으로 문제를 해결하기 위해 다양한 알고리즘들이 활용되며, 주로 이용되는 기법은 다음과 같음.

* [Brute-Force](#sec-01-01)

* [비트 마스크(Bitmask)](#sec-01-02)

* [재귀 함수](#sec-01-03)

* [다이나믹 프로그래밍](#sec-01-04)

* [순열](#sec-01-05)

* [DFS/BFS](#sec-01-06)


<br/>

<h3 id="sec-01-01">1. Brute-Force</h3>

for문과 if문 등을 활용해 문제에서 주어진 모든 case들에 대한 답을 구하는 방법.

<br/>
<h3 id="sec-01-02">2. 비트 마스크(Bitmask)</h3>

비트 연산을 통해 부분집합을 표현하는 방법. 문제에서 나올 수 있는 모든 경우의 수가 각각의 원소가 포함되거나, 포함되지 않는 두가지 선택으로 구성되는 경우 유용하게 활용 가능.

<br/>
<h3 id="sec-01-03">3. 재귀 함수</h3>

문제를 해결하기 위한 방법을 모두 탐색하기 위해, 재귀 함수를 통해 문제를 만족하는 경우들을 재귀적으로 만들어가는 방법. DP와 달리 크고 작은 문제의 구조가 다를 수 있고, 이전 결과를 반드시 기억하는 것이 아니라는 차이점이 있음.

<br/>

<h3 id="sec-01-04">4. 다이나믹 프로그래밍</h3>

DP는 작은 문제와 큰 문제가 동일한 구조를 가져, 큰 문제의 답을 구할 시 작은 문제에서 구한 결과를 기억하고 이를 그대로 사용해 수행 속도를 높인 방법을 말함. DP는 문제가 다음 두 가지의 조건을 만족하는 경우 사용이 가능함.

1. Overlapping Subproblems

    DP는 기본적으로 문제를 나누고 문제의 결과 값을 재활용하여 전체 답을 구함. 따라서 동일한 작은 문제들이 반복적으로 나타나는 경우 사용이 가능함. 다시 말해, DP는 부분 문제의 결과를 저장(Memoization)하여 같은 답을 중복하여 구하는 과정을 제거한 방법이다. 따라서 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능해짐.

2. Optimal Substructrue(최적 부분 구조)

    부분 문제의 최적 결과 값을 사용하여 전체 문제의 최적 결과값을 구할 수 있는 경우를 의미함. 다시 말해 특정 문제의 정답은 문제의 크기에 관계 없이 항상 동일해야 함.

<br/>
<h3 id="sec-01-05">5. 순열</h3>

임의의 수열이 있을 때, 이를 다른 순서로 연산하는 방법을 말함. 완전 탐색의 대표적인 유형. 서로 다른 N개의 원소를 일렬로 나열하는 순열의 경우의 수는 <img src="https://chart.apis.google.com/chart?cht=tx&chl=N!" />으로, 시간 복잡도가 매우 높음. 따라서 완전 탐색을 코딩 테스트에서 이용하기 위해서는 N이 1자리 수 정도가 되어야 함.

<br/>
<h3 id="sec-01-06">6. DFS/BFS</h3>

그래프 자료구조의 모든 정점을 탐색하는 방법.

<br/>

---
## Reference

* https://rebro.kr/59

* 종만북

* https://hongjw1938.tistory.com/78