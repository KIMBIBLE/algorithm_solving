# Problem Solving

* 종만북 내용 정리

## 1. 문제 해결의 6단계
  
  1. 문제를 읽고 이해하기
     * `제약조건`에 주의!
  2. 재정의와 추상화
     * 자기가 다루기 쉬운 개념을 이용해 문제를 `자기만의 언어로 재정의`!
     * 재정의 과정에서 복잡한 현실 문제의 `본질을 수학적/전산학적 개념으로 추상화`!
  3. 계획 세우기
     * 문제해결 전략: 문제해결 방식을 결정하고, 사용할 알고리즘 및 자료구조 선택
     * 문제해결 방식이 떠오르지 않을 떄를 위한 다양한 전략들에 대해 이해할 필요가 있음
  4. 계획 검증하기
     * 알고리즘 정당성 증명: 알고리즘이 모든 경우에 대한 요구조건을 정확히 수행한는지에 대한 증명
     * 알고리즘 효율성 분석: 수행시간과 메모리 제약 확인
  5. 계획 수행하기
     * 구현
  6. 회고하기
     * writeup
     * 다른사람 코드 보기

## 2. 문제 해결 전략
  
  * `직관`과 `체계적인 접근`
  * 체계적인 접근을 위한 질문들
    1. 비슷한 문제를 풀어본 적 있는가?
        * 형태가 비슷한 문제
          * 문제 해결 방법에 대한 원리를 알고있어야 변형된 문제에서 적용이 가능함
        * 문제의 목표가 같은 경우: 문제의 목적에 따른 적절한 접근 방법 선택
          * 문제 분류 방법: 최적화 문제, 경우의 수 문제, 검색 문제, ...
          * 각 알고리즘이 어느 문제 유형에서 사용 가능한지 숙지
          * 예시: 사건 발생확률이나 경우의 수 계산 문제는 대부분 DP로 풀림
        * sample : 합친 LIS, 신호 라우팅, 음주 운전 단속, 선거 공약
    2. 단순한 방법에서 시작할 수 있는가?
        * 어려운 문제를 최대한 단순한 해결 방법으로 접근해보고, 결과에 대해서 점진적으로 최적화
        * 이와 같은 방법은 점진적인 개선을 통해 문제 해결이 불가능하더라도, 알고리즘 효율성의 기준선을 정해줄 수 있다는 점에서 의의가 있음
        * sample: 쿼드 트리 뒤집기, 동적 계획법 문제들
    3. 문제 푸는 과정을 수식화 할 수 있는가?
        * 손으로 문제 풀어보는 습관: 간단한 예제 기반으로 규칙성 찾기 등
        * sample: Quantization, 두니발 박사의 탈옥, 실험 데이터 복구하기, 출전 순서 정하기, 마법의 약, 함정 설치
    4. 문제를 단순화 할 수는 없을까?
        * 문제를 단순화하여 변형
          * 변형방법: 문제 제약조건 없애기, 계산해야하는 변수 수 줄이기, 다차원 문제를 저차원으로 표현, ...
        * sample: 비대칭 타일링, 드래곤 커브, 도시락 데우기, 어린이날, 근거리 네트워크
    5. 그림으로 그려볼 수 있나?
        * sample: 문자열 합치기, 너드인가 너드가 아닌가?, 너드인가 너드가이닌가?2
    6. 수식으로 표현 가능한가?
        * 평문으로 쓰여진 문제를 수식으로 표현
        * sample: 수강 철회
    7. 문제 분해가 가능한가?
        * 문제를 더 쉬운 형태로 변형
        * 예시) 문제의 제약 조건을 분해하는 방법
          * 문제에 주어진 복잡한 조건을 더 단순한 형태의 조건 집합으로 분해
    8. 뒤에서부터 생각해서 문제를 풀 수 있나?
        * A->B로 가는 방법은 찾기 어렵지만, B->A로 가는 방법은 상대적으로 구하기 쉬운 경우도 종종 있음
        * sample: 삽입 정렬 뒤집기, 감시 카메라 설치, Sorting Game
    9. 순서를 강제할 수 있나?
        * 순서가 없는 문제에서 순서를 강제하여 문제를 해결하는 방법
        * 특정 조건을 만족하는 경우의 수를 셀 때 유용하게 사용 가능
          * 한가지 답을 두가지 이상으로 만들 수 있는 중복이 가능할 때, 순서를 임의로 부여함으로서 문제 해결이 쉬워질 수 있음
        * sample: 게임판 덮기, 폴리오미노, 웨브바짐
    10. 특정 형태의 답만을 고려할 수 있나?
        * 순서를 강제하는 기법의 연장선으로 정규화(canonicalization)이 있음
        * 정규화란?
          * 고려해야 할 답 중 형태가 다르지만 결과적으로 동일한 요소들을 그룹화한 후, 각 그룹의 대표들만을 고려하는 방식
          * 정규화를 통해 무한개의 모든 후보를 고려화하는 대신에 후보의 유한한 부분 집합만을 고려할 수 있음
        * 정규화 기법 적용을 위해 어떤 답이 주어진다고 했을 때, 이를 특정 형태의 답으로 변환할 수 있는 변형 과정을 찾아야함
          * 정규화 기법은 이와 같은 변형 과정을 찾는 방법이 문제마다 달라, 많은 경험을 통해 숙지하여 직관을 길러야 함
        * sample: 소풍, 단어 제한 끝말잇기

## 3. 문제 유형
  
  * 완전 탐색
    
    * Brute Force: 일반적으로 데이터의 갯수가 `100만 개 이하`일 때 사용하면 적절하다고 함.(동빈북)
    
    * BFS
    
    * Bitmask
    
    * Permutaion: 대략 <img src="https://chart.apis.google.com/chart?cht=tx&chl=O(N!)" />정도를 생각하면 됨.
    
    * Back Tracking


  * 이진 탐색
    * 이진 탐색은 <img src="https://chart.apis.google.com/chart?cht=tx&chl=%5Clog%7B%7D%7Bn%7D" />의 시간 복잡도를 가지기 때문에, 입력 데이터가 많거나 탐색 범위가 매우 넓은 문제에 활용하기 좋음.
    
    * 문제의 `데이터의 갯수가 1000만 개`를 넘어가거나 `탐색 범위의 크기가 1,000억 이상`이라면 이진 탐색 알고리즘을 사용하는 문제인지를 의심해보자!
    
      * `데이터의 갯수가 1000만 개 이상`: 탐색 범위의 크기가 좁은 경우는 배열 인덱스를 활용해 데이터를 저장하고 탐색하는 방법을 사용 가능.

      * `탐색 범위의 크기가 1,000억 이상`: 하지만 탐색 범위가 지나치게 넓은 경우 위와 같은 아이디어를 활용하기 어려움. 이 때 활용 가능한 방법이 이진 탐색!

    * 문제의 입력 데이터가 과도하게 많은 경우, 입력을 위해 소요되는 I/O overhead를 고려해야 함. 
    
      * 파이썬의 경우: `sys.readline()`을 활용하는 방법을 통해, 좀 더 빠르게 입력을 받을 수 있음.