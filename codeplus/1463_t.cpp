/* 
 * # 1463 : 1로 만들기
 * - 문제
 * 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
 * 
 * X가 3으로 나누어 떨어지면, 3으로 나눈다.
 * X가 2로 나누어 떨어지면, 2로 나눈다.
 * 1을 뺀다.
 * 
 * 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 
 * 연산을 사용하는 횟수의 최소값을 출력하시오.
 * 
 * - 입력
 * 첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 자연수 N이 주어진다.
 * 
 * - 출력
 * 첫째 줄에 연산을 하는 횟수의 최소값을 출력한다.
 *  
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * DP문제 D[n] = 연산을 사용하는 최솟값의 횟수
 * D[0] ~ D[n] 까지 메모를 다 채워넣는 방법을 구해서 풀면 된다.
 * 
 * D[n]의 부분 문제를 구해보면,
 * D[n] = 1('/3' 연산 1회) + D[n/3]
 * D[n] = 1('/2' 연산 1회) + D[n/2]
 * D[n] = 1('-1' 연산 1회) + D[n-1]
 * 이렇게 3가지 경우가 있을 수 있음.
 * 
 * D[n]의 부분분제의 최소 지점을 구해보면,
 * D[n] = '연산을 사용하는 최솟값의 갯수 = 0'을 만족하는 지점이
 * D[1]일 때가 된다.
 * 
 * D[n]에 메모하는 조건을 살펴보면, 새롭게 연산한 결과가
 * 이전에 D[n]에 메모된 값보다 작을때 메모하면 된다.
 * 이전에 메모한 값이 있는경우 메모한 값 리턴
 * 
 * 
 * - 생각
 * 
 * 
 * SOLVE 1> 
 * solve()는 d[n]을 메모한 후 리턴!
 * 
*/

// Solve 1
#include <iostream>
#include <vector>
using namespace std;

int solve(vector<int>&, int);

int main()
{
    int n;
    cin >> n;
    vector<int> dp(n+1, 0);
    cout << solve(dp, n);
}

int solve(vector<int>&dp, int n)
{
    if(n == 1) return 0;
    if(dp[n] > 0) return dp[n];

    dp[n] = solve(dp, n-1) + 1;
    if(n%3 == 0){
        int res = solve(dp, n/3) + 1;
        if(dp[n] > res) dp[n] = res;
    }
    if(n%2 == 0){
        int res = solve(dp, n/2) + 1;
        if(dp[n] > res) dp[n] = res;
    }

    return dp[n];
}