/* 
 * # 2346 : 풍선 터트리기
 * - 문제
 * N개의 풍선이 있다. 각 풍선 안에는 -N부터 N까지의 수가 
 * 적혀있는 종이가 들어 있다. 이 풍선들을 다음과 같은 규칙으로 터뜨린다.
 * 우선, 제일 처음에는 1번 풍선을 터뜨린다. 
 * 다음에는 풍선 안에 있는 종이를 꺼내어 그 종이에 적혀있는 값만큼 
 * 이동하여 다음 풍선을 터뜨린다. 양수가 적혀 있을 경우에는 오른쪽으로, 
 * 음수가 적혀 있을 때는 왼쪽으로 이동한다. 풍선은 원형으로 
 * 놓여 있다고 생각한다. 즉, 1번 풍선의 왼쪽에 N번 풍선이 있고, 
 * N번 풍선의 오른쪽에 1번 풍선이 있는 것이다. 이동할 때에는 이미 터진 
 * 풍선은 빼고 생각한다.
 * 예를 들어 다섯 개의 풍선 안에 차례로 3, 2, 1, -3, -1이 
 * 적혀 있었다고 하자. 이 경우 3이 적혀 있는 1번 풍선, 
 * -3이 적혀 있는 4번 풍선, -1이 적혀 있는 5번 풍선, 
 * 1이 적혀 있는 3번 풍선, 2가 적혀 있는 2번 풍선의 순서대로 터지게 된다.
 * 
 * - 입력
 * 첫째 줄에 자연수 N(1≤N≤1,000)이 주어진다. 다음 줄에는 차례로 각 풍선 
 * 안의 종이에 적혀 있는 수가 주어진다. 편의상 0은 적혀있지 않다고 가정하자.
 * 
 * - 출력
 * 첫째 줄에 터진 풍선의 번호를 차례로 나열한다.
 *  
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * (1) 자료구조 선정 : list(임의 접근, 요소 삽입&삭제)
 * 풍선들을 저장할 자료구조를 선택하기 위해 문제의 특성을 분석해보자.
 * 1~N 번째 풍선까지 연속적으로 위치하기 때문에 stl 컨테이너 중
 * 연속성을 갖는 컨테이너를 선택하는 것이 좋을 듯 하다.
 * STL 컨테이너 중 연속성을 갖는 컨테이너는
 * stack, queue, priority queue, deque, list, vector가 있는데
 * 풍선이 터지는 방식이 연속적이 아니라 임의의 풍선이 터지는 방식이기
 * 때문에 컨테이너의 데이터에 접근/삭제하는 방법에서 임의 접근이 가능해야하고
 * random access와 removal of element의 시간 복잡도가 낮은
 * 컨테이너를 선택하는 것이 효율적이다.
 * 
 * stack, queue, priority_queue, deque는 임의 접근에 경우 시간복잡도가
 * 비효율적이다.
 * 
 * list, vector중 vector는 임의 접근의 경우 O(1)이 되지만,
 * 요소 삽입&삭제의 경우 O(n)으로 마지막 요소로부터 거리에 비례하여
 * 시간이 증가하기 때문에
 * 임의접근, 요소 삽입&삭제를 O(1) 상수 시간 안에 지원하는
 * list 컨테이너를 선택하는 것이 효율적이다.
 * 
 * 추가적으로 list 자료구조를 통해 풍선의 순서를 명시하기 위해
 * 이를 pair를 통해 묶어줄 필요가 있다.
 * 
 * 
 * (2) 삭제 알고리즘
 * 해당 문제는 리스트를 논리적인 원형으로 유지 해 줘야 하고,
 * 리스트 삭제 때문에 리스트의 인덱스가 꼬여버리는 경우가 있어서
 * 알고리즘 짜는데 삽질을 많이 했다.
 * 
 * 리스트 자료구조를 사용한다고 했을 때 풍선을 터트린다는 것의
 * 정의를 어떻게 할지를 정해야 한다. 이를 위해선 먼저 풍선의 상태를
 * 리스트에 어떤 방식으로 저장해야 할 지에 대한 고민이 필요하다.
 * 단순하게 생각해보면 다음 터트릴 풍선의 위치(+x or -x)를 저장하고,
 * 풍선을 터트릴 때, 풍선 안에 있는 다음 터트릴 풍선의 위치를 읽어와
 * 보관해 둔 후, 현재 인덱스가 가리키는 풍선을 삭제해준다. 이후
 * 새롭게 터트려야 할 풍선의 인덱스를 원형 리스트의 특성을 고려해
 * 업데이트 해 주는 과정을 반복하면 될 듯 하다. 여기서 인덱스를
 * 포인터로 관리할 것인가 아니면 정수로 관리하고, 리스트에 특정
 * 인덱스에 접근하는 방법을 직접 구현해 줄 것인가에 따라 구현 방법이
 * 나뉘어 질 듯 하다. 어차피 인덱스를 정수로 관리한다고 하더라도,
 * 결국 접근시에는 list의 특성 상 임의 접근이 vector만큼의 효율성이
 * 나오지 않기 때문에 포인터로 상대적인 위치를 관리해주는것이
 * 편할듯.
 * 
 * 풍선이 남아있지 않을 때 까지 풍선 터트리기 과정을 반복하기 때문에
 * 반복 횟수는 풍선 리스트의 size가 0이 될 때 멈추면 된다. 
 * 
 * 
 * SOLVE 1> 
 * // 초기 설정
 * - N개만큼 사용자 입력을 읽어와 풍선 리스트를 생성한다.
 * - 터트려야 할 위치의 초기 값을 list의 맨 처음을 가리키도록 iterator
 * 형태로 설정.
 * 
 * // 반복(list.size())
 * - 현재 iterator가 가리키는 풍선에 저장된 값을 읽어 옴.
 * - 현재 iterator가 가리키는 풍선 삭제(삭제 후 iter가 한칸 뒤로
 *   이동한다는 특성 고려). 삭제 한 후 iter가 list.end()라면
 *   iter=list.begin()
 * - 읽어온 값을 통해 iterator를 이동 *(세부 구현 필요)
 * 
 * // 읽어온 값을 통해 iterator를 이동 *(세부 구현 필요)
 * 왼쪽 오른쪽 경계를 넘는지 여부, 왼쪽 오른쪽 이동시 iter 값 계산
 * 방법을 찾아야 함.
 * - 왼쪽 이동의 경우 -x 값만큼 이동하면 되지만,
 *   오른쪽으로 이동 할 경우 x-1 만큼 이동(삭제 후 iter 값 변화 때문)
 * - 경계값 넘는지에 대한 판별
 *   -- 연산 시 현재 iter == list.begin()이라면, iter = list.end()
 *   설정 한 다음 -- 연산 수행.
 *   ++ 연산 시 현재 iter+1 == list.end()이라면, iter = list.begin()
 *   설정 한 다 음 ++ 연산 수행.
 * 3, 2, 1, -3, 4
 */

// Solve 1
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

int main()
{
    int N;
    cin >> N;

    list<pair<int,int>> l;
    for(int i=1; i<=N; i++)
    {
        int num;
        cin >> num;
        l.push_back({i,num});
    }

    auto iter = l.begin();
    while(l.size())
    {
        int move = iter->second;
        cout << iter->first << ' ';
        iter = l.erase(iter);
        if(iter == l.end())
            iter = l.begin();

        if(move>0) // 오른쪽 이동
        {
            while(--move)
            {
                ++iter;
                if(iter == l.end())
                    iter = l.begin();
            }
        }
        else // 왼쪽 이동
        {
            while(move++)
            {
                if(iter == l.begin())
                    iter = l.end();
                --iter;
            }
        }

    }

    return 0;
}