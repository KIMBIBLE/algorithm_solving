/* 
 * # 1158 : 조세퍼스 문제
 * - 문제
 * 조세퍼스 문제는 다음과 같다.
 * 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 
 * 양의 정수 M(≤ N)이 주어진다. 이제 순서대로 M번째 사람을 
 * 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 
 * 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 
 * 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 
 * 순서를 (N, M)-조세퍼스 순열이라고 한다. 
 * 예를 들어 (7, 3)-조세퍼스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.
 * N과 M이 주어지면 (N,M)-조세퍼스 순열을 구하는 
 * 프로그램을 작성하시오.
 * 
 * - 입력
 * 첫째 줄에 N과 M이 빈 칸을 사이에 두고 순서대로 주어진다. 
 * (1 ≤ M ≤ N ≤ 5,000)
 * 
 * - 출력
 * 예제와 같이 조세퍼스 순열을 출력한다.
 *  
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * 자료구조를 원형으로 유지해서 푸는 문제.
 * 단순하게 생각해보면 데이터 삭제가 임의의 위치에서 이루어지기
 * 때문에 연결리스트로 이루어진 자료구조인 list, deque, queue 등을
 * 사용할 수 있다. 이들은 삭제가 선형 시간만큼 소요되기 때문에
 * 컨테이너를 논리적으로 원형으로 구성해 데이터 삭제를 반복하는
 * 방식을 사용할 수 있다. 이 경우 전체적인 시간복잡도 또한 선형으로
 * 나오는 방식이다.
 * 
 * 컨테이너를 논리적으로 원형의 형태로 구성하기 위한 방법으로
 * iter == x.end()일 때 iter = x.begin()으로 계속해서 업데이트
 * 해 주는 방법이 있을 수 있고, 다른 방법으로 queue를 사용할 경우
 * 삭제하지 않을 데이터에 대해서는 queue의 앞에서 pop을 해 주고
 * 이를 다시 queue의 뒤에 push해주는 방법이 있다.
 * 
 * 
 * - 생각
 * 원형 컨테이너 구현
 * it = l.erase(it)과 같이 list 를 삭제해주게 되면
 * it 뒤의 요소들이 앞으로 한칸씩 당겨진다.
 * 
 * 
 * SOLVE 2> 
 * 반복 : 이동(반복 : 이동 시 outofbound 체크) -> 출력 -> 삭제
 * (삭제 시 outofbound 체크)
 * 
*/

// Solve 2
#include <iostream>
#include <list>
using namespace std;

int main()
{
    list<int> l;
    int N, M;
    scanf("%d %d", &N, &M);

    for(int i=1; i<=N; i++)
    {
        l.push_back(i);
    }

    printf("<");
    auto it = l.begin();
    while(--N)
    {
        for(int i=1; i<M; i++)
        {
            ++it;
            if(it == l.end())
            {
                it = l.begin();
            }
        }
        printf("%d, ", *it);
        it = l.erase(it);
        if(it == l.end())
        {
            it = l.begin();
        }
    }
    printf("%d>", *it);
}