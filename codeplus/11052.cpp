/* 
 * # 11052 : 붕어빵 판매하기
 * - 문제
 * 
 * 강남역에서 붕어빵 장사를 하고 있는 해빈이는 지금 붕어빵이 N개 남았다.
 * 해빈이는 적절히 붕어빵 세트 메뉴를 구성해서 붕어빵을 팔아서 얻을 수 
 * 있는 수익을 최대로 만드려고 한다. 붕어빵 세트 메뉴는 붕어빵을 
 * 묶어서 파는 것을 의미하고, 세트 메뉴의 가격은 이미 정해져 있다.
 * 
 * 붕어빵 i개로 이루어진 세트 메뉴의 가격은 Pi 원이다.
 * 
 * 붕어빵이 4개 남아 있고, 1개 팔 때의 가격이 1, 2개는 5, 
 * 3개는 6, 4개는 7인 경우에 해빈이가 얻을 수 있는 최대 수익은 10원이다. 
 * 2개, 2개로 붕어빵을 팔면 되기 때문이다.
 * 
 * 1개 팔 때의 가격이 5, 2개는 2, 3개는 8, 4개는 10 인 경우에는 20이 된다. 
 * 1개, 1개, 1개, 1개로 붕어빵을 팔면 되기 때문이다.
 * 
 * 마지막으로, 1개 팔 때의 가격이 3, 2개는 5, 3개는 15, 4개는 16인 
 * 경우에는 정답은 18이다. 붕어빵을 3개, 1개로 팔면 되기 때문이다.
 * 세트 메뉴의 가격이 주어졌을 때, 해빈이가 얻을 수 있는 
 * 최대 수익을 구하는 프로그램을 작성하시오.
 * 
 * - 입력
 * 첫째 줄에 해빈이가 가지고 있는 붕어빵의 개수 N이 주어진다. 
 * (1 ≤ N ≤ 1,000)
 * 
 * 둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)
 * 
 * - 출력
 * 해빈이가 얻을 수 있는 최대 수익을 출력한다.
 *  
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * n개의 물건을 조합했을 때의 최대 금액을 구하는 문제
 * 
 * i값이 최대 1000까지 올 수 있기 때문에 1000^4 이 걸리는 4중 for문 같은
 * 비효율적인 알고리즘을 사용할 수 없다.
 * 
 * 솔직히 앞서 풀어본 DP 문제 같은 경우 문제를 보면 딱 DP를 사용할 경우
 * 효율적으로 풀 수 있을 것 같은 느낌이 왔지만, 이번 문제같은 경우는
 * DP 문제라는것을 모른 상태에서는 어떤 방식으로 문제를 풀어야 할 지에
 * 대한 감을 잡기 어려울 것 같다.
 * => 일단 풀어보고 이 문제 유형은 만나면 그냥 DP로 푸는 걸로
 * 외워두고 차근차근 나중에 더 살펴보자.
 * 
 * D[n] = n개의 물건을 조합했을 때의 최대 금액을 구하는 문제
 * 
 * n개의 물건을 조합했을 때의 최대 금액을 구하는 문제는 일단,
 * 1, ... , n-1의 경우에도 마찬가지로 같은 방법으로 풀이 방법을
 * 정의할 수 있기 때문에 각각의 부분문제를 구하는 방법이 동일하다고
 * 할 수 있다.
 * 
 * 그렇다면 이 문제가 부분문제를 이용해 구할 수 있는지 알아보기 위해
 * D[n]인 상태 즉, n개의 물건이 있을 때의 상황에서
 * 이를 이전 상태들의 조합을 통해 정의할 수 있는지 알아보자.
 * d[n]을 해결하기 위해 마지막에 위치하는 물건을 보면,
 * 마지막에 판 물건이 
 * 1개 짜리 일 때 : 1개짜리 묶음 가격 + d[n-1],
 * 2개 짜리 일 때 : 2개짜리 묶음 가격 + d[n-2], ...
 * n-1 짜리 일 때 : n-1짜리 묶음 가격 + d[1]
 * n   짜리 일 때 : n  짜리 묶음 가격 + d[0]
 * 의 조합으로 생각 가능하다. d[n]은 위의 경우 중 최댓값을 갖는
 * 경우에 해당된다.
 * 
 * 위의 경우를 일반화 해보면 마지막에 판 물건이
 * n=i 일 때, n-i개짜리 묶음 가격 + d[n-i]가 된다.
 * 
 * 
 * 부분문제의 최솟값은 n==0 인 경우 0
 * 
 * - 생각
 * DP 문제의 시간복잡도를 계산해보면,
 * 부분문제의 시간복잡도 O(N) * 풀어야 할 부분문제의 갯수 O(N)으로
 * 총 O(N^2)이 나온다.
 * O(N^2) 알고리즘의 경우 N이 10000 정도일 때, 걸리는 시간이
 * 보통 1초안쪽이 나오기 때문에 문제의 최대 N값인 1000의 경우
 * 문제없이 1초 시간제한 내에 들어올 수 있다.
 * 
 * SOLVE 1> 
 * 
 * 
*/

// Solve 1
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int solve(vector<int> &, vector<int> &, int);

int main()
{
    int n;
    cin >> n;
    vector<int> d(n+1, 0);

    vector<int> x(n+1, 0);
    for(int i=1; i<=n; i++){
        cin >> x[i];
    }

    cout << solve(d, x, n);    

}

int solve(vector<int> &d, vector<int> &x, int n)
{
    if(n == 0) return 0;
    if(d[n] > 0) return d[n];

    int max = d[0]; // default memo(min value of memo)
    for(int i=1; i<=n; i++){
        int tmp = solve(d, x, n-i) + x[i];
        if(max < tmp) max = tmp; 
    }
    d[n] = max;
    
    return d[n];
}