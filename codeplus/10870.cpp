/* 
 * # 10870 : 피보나치 수 5
 * - 문제
 * 피보나치 수는 0과 1로 시작한다. 
 * 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 
 * 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
 * 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n>=2)가 된다.
 * n=17일때 까지 피보나치 수를 써보면 다음과 같다.
 * 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
 * n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.
 * 
 * - 입력
 * 첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.
 * 
 * - 출력
 * 첫째 줄에 n번째 피보나치 수를 출력한다.
 *  
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * 재귀 + 람다함수를 이용하여 풀어볼 것
 * 
 * # <재귀>
 * 재귀적으로 문제를 푼다? : 동일한 형태의 부분 문제를 풀어간다.
 * => 자기 자신 호출 + 문제 해결 완료 시 종료
 * 부분 문제를 어떻게 정의해야 할까?
 * 부분 문제를 정의할 때 부분 문제의 현재 상태와 다음 상태와의 관계를
 * 찾아내는 것이 중요. 대표적인 예로 점화식을 생각해 보면 됨.
 * 
 * - 생각
 * Divide and Conquer 문제해결을 위해 문제 최소 단위를 쪼개자
 * 피보나치 수는 현재 결과가 이전 2개의 결과의 합.
 * 따라서 n번째 피보나치 수를 구하는 문제가
 * n-1번째 피보나치 수를 구하는 문제와 n-2번째 피보나치 수를 구하는
 * 문제로 정의됨.
 * 
 * Fn을 구하기 위한 함수는 결국 문제 해결을 Fn-1 + Fn-2 의 함수로 위임하고,
 * 이 위임 과정들이 반복된다고 할 수 있다.
 * 이러한 방식의 문제 풀이는 더이상 문제를 위임할 수 없는 상태 즉, 
 * 반복이 종료되어야 하는 지점까지 반복됨.
 * 
 * 피보나치 수의 경우 F2=F1+F0 상태까지 위임을 진행하면
 * F1, F0의 경우 n이 0이상이라는 조건에 의해 더이상 문제를 위임할 수 없기
 * 때문에 이 F1, F0이 반복의 종료 지점이 된다.
 * 
 * SOLVE 1> 
 * Fn = Fn-1 + Fn-2 을 함수로 정의 해보면
 * [&]func(int n){ return func(n-1) + func(n-2);} 이 되고
 * 위에서 위임과정의 반복을 종료시키기 위한 조건을
 * n이 1이하인 경우 n 값을 리턴하는 방식을 사용하면 문제를 해결할 수 있음.
 * 
 * 람다함수를 이용해 재귀적 문제를 풀기 때문에 
 * auto 키워드를 사용할 경우 func(n) 함수 정의 시점에 
 * func(n-1), func(n-2) 호출에 대한 정의가 이루어지 않은 상태이기 떄문에
 * 컴파일 타임에 auto 키워드가 적합한 함수 시그니처를 알 수 없음.
 * 따라서 이 경우 변수 선언 시 functional 헤더에 있는 
 * 적합한 함수 시그니처를 명시해 줘야 함.
*/

// Solve 1
#include <functional>
#include <iostream>
using namespace std;

int main()
{
    int n;
    cin >> n;

    // auto로 지정할 경우 에러!
    function<int(int)> f = [&](int n)
    {
        if(n<=1)
            return n;
        else
            return f(n-1) + f(n-2);
    };

    cout << f(n) << endl;
}