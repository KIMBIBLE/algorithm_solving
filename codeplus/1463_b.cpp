/* 
 * # 1463 : 1로 만들기
 * - 문제
 * 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
 * 
 * X가 3으로 나누어 떨어지면, 3으로 나눈다.
 * X가 2로 나누어 떨어지면, 2로 나눈다.
 * 1을 뺀다.
 * 
 * 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 
 * 연산을 사용하는 횟수의 최소값을 출력하시오.
 * 
 * - 입력
 * 첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 자연수 N이 주어진다.
 * 
 * - 출력
 * 첫째 줄에 연산을 하는 횟수의 최소값을 출력한다.
 *  
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * DP문제 D[n] = 연산을 사용하는 최솟값의 횟수
 * D[0] ~ D[n] 까지 메모를 다 채워넣는 방법을 구해서 풀면 된다.
 * 
 * D[n]의 부분 문제를 구해보면,
 * D[n] = 1('/3' 연산 1회) + D[n/3]
 * D[n] = 1('/2' 연산 1회) + D[n/2]
 * D[n] = 1('-1' 연산 1회) + D[n-1]
 * 이렇게 3가지 경우가 있을 수 있음.
 * 
 * D[n]의 부분분제의 최소 지점을 구해보면,
 * D[n] = '연산을 사용하는 최솟값의 갯수 = 0'을 만족하는 지점이
 * D[1]일 때가 된다.
 * 
 * D[n]에 메모하는 조건을 살펴보면, 새롭게 연산한 결과가
 * 이전에 D[n]에 메모된 값보다 작을때 메모하면 된다.
 * 이전에 메모한 값이 있는경우 메모한 값 리턴
 * 
 * 
 * - 생각
 * 
 * 
 * SOLVE 2> 
 * bottom up 방식으로 풀어보자!
 * top down 방식과 시간 비교를 해 보니
 * 놀랍게도 메모리 사용량, 시간 적인 측면에서
 * 10배 정도의 효율을 보여준다!
 * 
*/

// Solve 2
#include <iostream>
#include <vector>
using namespace std;

int solve(vector<int>&, int);

int main()
{
    int n;
    cin >> n;
    vector<int> dp(n+1, 0);
    cout << solve(dp, n);
}

int solve(vector<int>&dp, int n)
{
    for(int i=2; i<=n; i++){
        // -1 의 경우 먼저 계산
        dp[i] = dp[i-1] + 1;

        if(i%3 == 0){
            int tmp = dp[i/3] + 1;
            if(dp[i] > tmp) dp[i] = tmp;
        }
        if(i%2 == 0){
            int tmp = dp[i/2] + 1;
            if(dp[i] > tmp) dp[i] = tmp;
        }
    }

    return dp[n];
}