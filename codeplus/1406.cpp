/* 
 * # 1406 : 에디터
 * - 문제
 * 한 줄로 된 간단한 에디터를 구현하려고 한다. 
 * 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 
 * 최대 600,000글자까지 입력할 수 있다.
 * 
 * 이 편집기에는 '커서'라는 것이 있는데, 
 * 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 
 * 문장의 맨 뒤(마지막 문자의 오른쪽), 
 * 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 
 * 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 
 * 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.
 * 이 편집기가 지원하는 명령어는 다음과 같다.
 * 
 * L : 커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)
 * D : 커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)
 * B : 커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨)
 * 삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 
 * 실제로 커서의 오른쪽에 있던 문자는 그대로임.
 * P $ : $라는 문자를 커서 왼쪽에 추가함.
 * 
 * 초기에 편집기에 입력되어 있는 문자열이 주어지고, 
 * 그 이후 입력한 명령어가 차례로 주어졌을 때, 
 * 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 
 * 문자열을 구하는 프로그램을 작성하시오. 
 * 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 
 * 위치하고 있다고 한다.
 * 
 * - 입력
 * 첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 
 * 이 문자열은 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 
 * 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 N(1≤N≤500,000)이 주어진다. 
 * 셋째 줄부터 N개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 
 * 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.
 * 
 * 예제 1>
 * abcd
 * 3
 * P x
 * L
 * P y
 * 
 * 
 * - 출력
 * 예제 1> 
 * 
 * 
 * 
 * - 시간제한
 * 1 초 (언어별 추가 시간 없음)
 * 아직까지 stl 및 알고리즘에 따른 실제 소요 시간에 대한 개념이 덜 잡혔기 때문에,
 * 최대한 시간복잡도가 상수 O(1)인 자료구조 위주로 사용하는 방식으로 문제를 풀 것이다.
 * 
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * 편집기라는 특성상 sequence container를 선택해야 하고,
 * 중간에 삽입, 삭제가 빈번하게 이루어 질 수 있다는 점을
 * 감안했을 때, random access 와 insert/removal of element의 시간복잡도가
 * O(N)인 vector보다 O(1) list를 사용해 각각의 노드에 문자를 저장하는 것이 
 * 효율적일 것이다.
 * 
 * 그 다음으로 고려해야 할 사항은 커서의 특징을 논리적으로 구현하는 방법이다.
 * 커서의 특징을 살펴보면 아래와 같이 정리할 수 있다.
 * (1) 삽입시 커서 뒤에, 삭제시 커서 앞의 데이터가 삭제
 * (2) 커서의 이동은 맨앞, 맨뒤에서 이동할 시 무시됨.
 * (3) 커서의 삭제는 현재 커서의 위치가 맨 앞일 경우 무시됨.
 * 
 * 
 * - 생각
 * list를 사용하기 떄문에 커서를 iterator를 통해 구현하는 것이 편리할 것이다.
 * 그렇다면 커서 iter가 list의 어디를 가리키는 상태가 되어야할까?
 * 먼저 가장 직관적으로 커서가 현재 입력된 데이터를 가리키는 상태를 가정해보자
 * 좌/우 이동의 경우 iter를 ++, --하는 방식으로 간단히 구현이 가능할 것이고,
 * insert의 경우 현재 iter 앞의 노드에 삽입이 되고, 
 * 삭제는 iter가 가리키는 노드가 삭제되기 떄문에 구현이 간편할 것이라고
 * 예상할 수 있다. 결국 이 방식(커서가 현재 입력된 데이터를 가리키는 방식)은
 * iter를 erase()의 기준에 맞추어 구현하는 방식이다.
 * 
 * SOLVE 1> 
 * 
 * abcdX
*/

// Solve 1
#include <list>
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string s;
    cin >> s;
    list <int> l(s.begin(), s.end());
    auto cur = l.end();
    // 삽입 : insert(cur)
    // 삭제 : 현재 커서 앞에 노드로 이동하여 해당 노드 삭제
    // cur = l.begin() => 커서가 맨 앞인 상태

    auto leftMove = [&](){
        if(cur != l.begin())
            --cur;
    };

    auto rightMove = [&](){
        auto tmp = cur;
        ++tmp;
        if(cur != l.end())
            cur = tmp;
    };

    auto del = [&](){
        if(cur != l.begin())
        {
            cur = l.erase(--cur);
        }
    };

    auto ins = [&](){
        char x;
        cin >> x;
        l.insert(cur, x);
    };

    auto print = [&](){
        for(auto each : l)
        {
            cout << static_cast<char>(each);
        }
    };

    int cnt;
    cin >> cnt;
    for(int i=0;i<cnt;i++)
    {
        char cmd;
        cin >> cmd;
        if(cmd == 'L')
            leftMove();
        else if(cmd == 'D')
            rightMove();
        else if(cmd == 'B')
            del();
        else if(cmd == 'P')
            ins();
        else{;}
    }
    print();

    return 0;
}