/* 
 * # 10815 : 숫자 카드
 * - 문제
 * 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 
 * 숫자 카드 N개를 가지고 있다. 숫자 M개가 주어졌을 때, 
 * 이 숫자가 적혀있는 숫자 카드를 상근이가 가지고 있는지 
 * 아닌지를 구하는 프로그램을 작성하시오.
 * 
 * - 입력
 * 첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N 
 * (1 ≤ N ≤ 500,000)이가 주어진다. 둘째 줄에는 숫자 카드에 
 * 적혀있는 숫자가 주어진다. 숫자 카드에 적혀있는 숫자는 
 * -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 
 * 두 숫자 카드에 같은 숫자가 적혀있는 경우는 없다.
 * 
 * 셋째 줄에는 M (1 ≤ M ≤ 500,000)이 주어진다. 
 * 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 
 * 구해야 할 M개의 숫자가 주어지며, 이 숫자는 공백으로 
 * 구분되어져 있다. 이숫자도 -10,000,000보다 크거나 같고, 
 * 10,000,000보다 작거나 같다
 * 
 * - 출력
 * 첫째 줄에 입력으로 주어진 M개의 숫자에 대해서, 
 * 각 숫자가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 
 * 아니면 0을 공백으로 구분해 출력한다.
 *  
 * *********************************************************************************
 * 
 * # writeup
 * - 분석
 * 일련의 카드를 입력받아 저장한 후, 뒤에 입력으로 들어온
 * 카드들이 초기 입력받은 카드 리스트에 포함되어있는지
 * 검사하는 문제이다.
 * 
 * 
 * 입력 순서와 저장 순서간 상관관계가 없고 중복이 포함되지
 * 않은 데이터가 주어지기 때문에 stl 중 set을 사용하는 것이
 * 편리함.
 * 
 * stl set은 red black tree로 구현되어있기 때문에
 * 초기 데이터 입력 시 NlogN의 시간 복잡도가,
 * 이후 m개의 데이터에 대한 검사 시 MlogN의 시간복잡도가
 * 소요되어 총 (M+N)logN의 시간복잡도를 예상할 수 있다.
 * 
 * - 생각
 * red black tree 알고리즘에 대해 좀 더 자세히 조사해보자.
 * 
 * SOLVE 1> 
 * cin 사용하면 시간제한에 걸림 => 입력은 웬만하면 scanf 쓰자... 
 * 
*/

// Solve 1
#include <set>
#include <iostream>
using namespace std;

int main()
{
    set <int>s;
    int N;
    int num;
    scanf("%d", &N);

    // NlogN
    for(int i=0; i<N; i++)
    {
        scanf("%d", &num);
        s.insert(num);
    }

    int M;
    scanf("%d", &M);
    for(int i=0; i<M; i++)
    {
        int num;
        scanf("%d", &num);
        printf("%d ", static_cast<int>(s.count(num)));
        /*
        auto it = s.find(num);
        if(it != s.end())
        {
            cout << "1 ";
        }
        else
        {
            cout << "0 ";
        }
        */
    }
}
